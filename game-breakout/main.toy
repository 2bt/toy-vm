include "prelude.toy"
include "util.toy"

const Q = 256

const BORDER    = 18
const BALL_W    = 4
const BLOCK_W   = 16
const PAD_W     = 10
const PAD_RIGHT = 48
const PAD_SPEED = 2 * Q


struct Ball
    x
    y
    vx
    vy
    alive
end

struct Block
    x
    y
    alive
end

struct Pad
    y
    h
end

var balls:  Ball[20]
var blocks: Block[117]
var pad:    Pad

var blocks_alive
var balls_alive

func Ball_add(x, y): Ball*
    for var b = balls.ptr, b < balls.limit, b += 1 do
        if b.alive == 0 then
            b.alive = 1
            b.x  = x
            b.y  = y
            b.vx = 600 + rand(-100, 100)
            b.vy = rand(-400, 400)
            return b
        end
    end
    return 0
end


func Box_overlaps(ax, ay, aw, ah, bx, by, bw, bh)
    return ax < bx + bw and ax + aw > bx and
           ay < by + bh and ay + ah > by
end
func Box_overlap_x(ax, ay, aw, ah, bx, by, bw, bh)
    if not Box_overlaps(ax, ay, aw, ah, bx, by, bw, bh) then return 0 end
    var d1 = bx + bw - ax
    var d2 = bx - (ax + aw)
    if abs(d1) < abs(d2) then return d1 else return d2 end
end


func init()

    pad.h = 30
    pad.y = (SCREEN_H/2 - (pad.h / 2)) * Q

    for var i = 0, i < 3, i += 1 do
        Ball_add(PAD_RIGHT * Q, pad.y + (pad.h / 2 - BALL_W / 2) * Q)
    end


    var k = blocks.ptr
    for i = 4, i < 11, i += 1 do
        for var j = 2, j < 7, j += 1 do
            k.alive = 1
            k.x = 94 + i * BLOCK_W
            k.y = BORDER + j * BLOCK_W
            k += 1
        end
    end

    while k < blocks.limit do
        k.alive = 0
        k += 1
    end

end




func Ball_update(b: Ball*)

    if b.alive == 0 then return end
    balls_alive += 1

    b.x += b.vx
    if b.vx < 0 then

        if b.x < -100 * Q then
            b.alive = 0
        end

        # collision with pad
        if b.x <= PAD_RIGHT * Q and b.x > (PAD_RIGHT - 4) * Q then
            if b.y + BALL_W/2*Q >= pad.y and b.y <= pad.y + pad.h * Q then
                b.x = PAD_RIGHT * Q
                b.vx *= -1
            end
        end


    elif b.vx > 0 then
        if b.x > (SCREEN_W - BALL_W - BORDER) * Q then
            b.x = (SCREEN_W - BALL_W - BORDER) * Q
            b.vx *= -1
        end
    end


    var hit = 0
    for var k = blocks.ptr, k < blocks.limit, k += 1 do
        if k.alive == 0 then continue end
        if Box_overlaps(b.x / Q, b.y / Q, BALL_W, BALL_W, k.x, k.y, BLOCK_W, BLOCK_W) then
            k.alive = 0
            hit = 1
        end
    end
    if hit then b.vx *= -1 end


    b.y += b.vy
    if b.y < BORDER * Q then
        b.y = BORDER * Q
        b.vy *= -1
    end
    if b.y > (SCREEN_H - BALL_W - BORDER) * Q then
        b.y = (SCREEN_H - BALL_W - BORDER) * Q
        b.vy *= -1
    end



    sprite(b.x / Q, b.y / Q, BALL_W, BALL_W, 16, 224, 0)

end



func update()

    # draw stage
    sprite(0, 0, SCREEN_W, SCREEN_H, 0, 32, 0)


    # draw blocks
    blocks_alive = 0
    for var k = blocks.ptr, k < blocks.limit, k += 1 do
        if k.alive != 0 then end
        if k.alive then end

        if k.alive != 0 then
            blocks_alive += 1
            sprite(k.x, k.y, BLOCK_W, BLOCK_W, 32, 224, 0)
        end
    end



    # pad
    if btn & BTN_UP   then pad.y -= PAD_SPEED end
    if btn & BTN_DOWN then pad.y += PAD_SPEED end
    pad.y = clamp(pad.y, BORDER * Q, (SCREEN_H - BORDER - pad.h) * Q)

    sprite(PAD_RIGHT - PAD_W, pad.y / Q, PAD_W, pad.h - 8, 0, 224, 0)
    sprite(PAD_RIGHT - PAD_W, pad.y / Q + pad.h - 8, PAD_W, 8, 0, 224, 2)


    # update balls
    balls_alive = 0
    for var b = balls.ptr, b < balls.limit, b += 1 do
        Ball_update(b)
    end

    # spawn new ball
    if balls_alive == 0 then
        Ball_add(PAD_RIGHT * Q, pad.y + (pad.h / 2 - BALL_W / 2) * Q)
    end


    print(5, 5, "Balls")
    print(5 + 8*6, 5, int_to_str(balls_alive))

    print(10*8 + 5, 5, "Blocks")
    print(10*8 + 5 + 8*7, 5, int_to_str(blocks_alive))
end
