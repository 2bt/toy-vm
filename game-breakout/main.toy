include "prelude.toy"
include "util.toy"
include "sound.toy"

const Q = 256

const BALL_STATE_DEAD     = 0
const BALL_STATE_FLYING   = 1
const BALL_STATE_STICKING = 2

const BLOCK_STATE_DEAD   = 0
const BLOCK_STATE_NORMAL = 1
const BLOCK_STATE_DYING  = 2
const BLOCK_THEMES = 4
const BLOCK_TYPE_NORMAL    = 0
const BLOCK_TYPE_EXTRABALL = 1

const GAME_STATE_PLAYING = 0
const GAME_STATE_CLEAR   = 1
const GAME_STATE_DEAD    = 2

const BORDER       = 18
const BALL_W       = 8
const BLOCK_W      = 16
const PAD_W        = 8
const PAD_X        = 38
const PAD_START_H  = 40
const ACC          = 100


struct Ball
    state
    tick
    frame
    x
    y
    vx
    vy
    spin
end


struct Block
    state
    tick
    frame
    theme
    type
    x
    y
end

struct Pad
    is_sticky
    y
    h
    vy
end

var game_state
var blocks_alive
var balls_alive
var balls_spinning
var lives
var score

var balls:  Ball[20]
var blocks: Block[117]
var pad:    Pad

var prev_input

func is_just_pressed(button)
    return input & button & (-1-prev_input)
end


func new_ball(): Ball*
    for var b = balls.ptr, b < balls.limit, b += 1 do
        if b.state != BALL_STATE_DEAD then continue end
        b.state = BALL_STATE_STICKING
        b.tick  = 0
        b.spin  = 0
        b.x     = (PAD_X + PAD_W) * Q
        b.y     = pad.y + pad.h * (Q / 2) - BALL_W * Q / 2
        b.vx    = 500
        b.vy    = 400
        if rand(0, 1) then b.vy *= -1 end
        return b
    end
end

func unstick_balls()
    for var b = balls.ptr, b < balls.limit, b += 1 do
        if b.state != BALL_STATE_STICKING then continue end
        b.state = BALL_STATE_FLYING
        sound(SOUND_UNSTICK)
    end
end


func init_stage()
    game_state = GAME_STATE_PLAYING

    # pad
    pad.is_sticky = 0
    pad.vy        = 0
    pad.h         = PAD_START_H
    pad.y         = (SCREEN_H/2 - (pad.h / 2)) * Q

    # balls
    for var b = balls.ptr, b < balls.limit, b += 1 do
        b.state = BALL_STATE_DEAD
    end
    new_ball()

    # blocks
    blocks_alive = 0
    var k = blocks.ptr
    for var i = 4, i < 11, i += 1 do
        for var j = 0, j < 9, j += 1 do
            blocks_alive += 1
            k.state = BLOCK_STATE_NORMAL
            k.theme = rand(0, BLOCK_THEMES - 1)
            k.tick  = 0
            k.x     = 94 + i * BLOCK_W
            k.y     = BORDER + j * BLOCK_W
            k.type  = BLOCK_TYPE_NORMAL
            k += 1
        end
    end
    while k < blocks.limit do
        k.state = BLOCK_STATE_DEAD
        k += 1
    end

    i = 5
    while i do
        k = &blocks[rand(0, blocks_alive - 1)]
        if k.type == BLOCK_TYPE_NORMAL then
            k.type = BLOCK_TYPE_EXTRABALL
            i -= 1
        end
    end
end

func init()
    lives = 3
    score = 0
    init_stage()
end


const AXIS_X = 0
const AXIS_Y = 1

func block_collision(b: Ball*, axis)

    var overlap = 0
    for var k = blocks.ptr, k < blocks.limit, k += 1 do
        if k.state != BLOCK_STATE_NORMAL then continue end
        var o
        if axis == AXIS_X then
            o = box_overlap_x(b.x / Q, b.y / Q, BALL_W, BALL_W, k.x, k.y, BLOCK_W, BLOCK_W)
        else
            o = box_overlap_y(b.x / Q, b.y / Q, BALL_W, BALL_W, k.x, k.y, BLOCK_W, BLOCK_W)
        end
        if o then
            overlap = o
            score        += 1
            blocks_alive -= 1
            k.state = BLOCK_STATE_DYING
            # extra ball!
            if k.type == BLOCK_TYPE_EXTRABALL then
                var n = new_ball()
                if n then
                    n.state = BALL_STATE_FLYING
                    n.x = b.x
                    n.y = b.y
                    if rand(0, 1) == 0 then
                        b.vx *= -1
                    end
                end
            end
        end
    end
    if overlap then
        sound(SOUND_BLOCK)
        if axis == AXIS_X then
            b.vx *= -1
            b.x = ((b.x / Q) + overlap) * Q
        else
            b.vy *= -1
            b.y = ((b.y / Q) + overlap) * Q
        end
        b.vx += rand(-20, 20)
        b.vy += rand(-20, 20)
    end
end


func update_ball(b: Ball*)
    if b.state == BALL_STATE_DEAD then return end

    # pad y collision
    var overlap = box_overlap_y(b.x / Q, b.y / Q, BALL_W, BALL_W, PAD_X, pad.y / Q, PAD_W, pad.h)
    if overlap then
        sound(SOUND_BING)

        b.y = ((b.y / Q) + overlap) * Q
        if pad.vy > 0 then
            b.vy = abs(pad.vy)
        elif pad.vy < 0 then
            b.vy = -abs(pad.vy)
        else
            b.vy *= -1
        end
    end


    # spin
    b.spin = clamp(0, b.spin - 20, b.spin + 20)
    var s = clamp(b.spin, -100, 100)
    if s != 0 then
        var nx = b.vx
        var ny = b.vy
        b.vx += ny * s / 6000
        b.vy -= nx * s / 6000
    end

    # move x
    if b.state != BALL_STATE_STICKING then
        b.x += b.vx
    end

    # pad collision
    overlap = box_overlap_x(b.x / Q, b.y / Q, BALL_W, BALL_W, PAD_X, pad.y / Q, PAD_W, pad.h)
    if overlap then
        sound(SOUND_BING)

        b.x    = ((b.x / Q) + overlap) * Q
        b.spin = pad.vy
        var speed = sqrt(b.vx * b.vx + b.vy * b.vy)
        speed += 5 # increase speed
        b.vx = abs(b.vx)
        b.vy += pad.vy / 4
        var speed2 = sqrt(b.vx * b.vx + b.vy * b.vy)
        b.vx   = b.vx * speed / speed2
        b.vy   = b.vy * speed / speed2
        b.tick = 0
        if pad.is_sticky then
            b.state = BALL_STATE_STICKING
        end
    end


    # block collision
    block_collision(b, AXIS_X)

    # wall collision
    if b.x > (SCREEN_W - BALL_W - BORDER) * Q then
        b.x = (SCREEN_W - BALL_W - BORDER) * Q
        b.vx = -abs(b.vx)
        sound(SOUND_BING)
    end


    # move y
    if b.state != BALL_STATE_STICKING then
        b.y += b.vy
    else
        b.y += pad.vy
    end

    # block collision
    block_collision(b, AXIS_Y)

    # wall collision
    if b.y < BORDER * Q then
        sound(SOUND_BING)
        b.y = BORDER * Q
        b.vy = abs(b.vy)
    end
    if b.y > (SCREEN_H - BALL_W - BORDER) * Q then
        sound(SOUND_BING)
        b.y = (SCREEN_H - BALL_W - BORDER) * Q
        b.vy = -abs(b.vy)
    end

    # die
    if b.x < -BALL_W * Q then
        b.state = BALL_STATE_DEAD
    end

    # set frame
    b.frame = 0
    if b.spin != 0 then
        b.frame = 1 + b.tick % 8
        if b.spin > 0 then b.frame = 9 - b.frame end
    end

    balls_alive += 1
    if b.spin != 0 then
        balls_spinning += 1
    end

    b.tick += 1
end



func update_stage()
    if game_state == GAME_STATE_PLAYING then

        # pad
        var dy = 0
        if input & INPUT_UP   then dy -= 1 end
        if input & INPUT_DOWN then dy += 1 end
        pad.vy = clamp(dy * (4 * Q), pad.vy - ACC, pad.vy + ACC)

        pad.y += pad.vy
        if pad.y < BORDER * Q then
            pad.y = BORDER * Q
            pad.vy = 0
        end
        if pad.y > (SCREEN_H - BORDER - pad.h) * Q then
            pad.y = (SCREEN_H - BORDER - pad.h) * Q
            pad.vy = 0
        end

        if is_just_pressed(INPUT_A) then
            unstick_balls()
        end

        # balls
        balls_alive = 0
        var prev_spinning = balls_spinning
        balls_spinning = 0
        for var b = balls.ptr, b < balls.limit, b += 1 do
            update_ball(b)
        end
        if balls_alive == 0 then
            sound(SOUND_DIE)
            if lives > 0 then
                lives -= 1
                new_ball()
            else
                game_state = GAME_STATE_DEAD
            end
        end
        if prev_spinning != balls_spinning then
            if prev_spinning == 0 then sound(SOUND_SPIN) end
            if balls_spinning == 0 then sound(SOUND_NOSPIN) end
        end

        # stage clear
        if blocks_alive <= 0 then
            for b = balls.ptr, b < balls.limit, b += 1 do
                b.vx = 0
                b.vy = 0
            end
            game_state = GAME_STATE_CLEAR
        end

    elif game_state == GAME_STATE_CLEAR then
        if is_just_pressed(INPUT_A) then
            init_stage()
        end
    elif game_state == GAME_STATE_DEAD then
        if is_just_pressed(INPUT_A) then
            init()
        end
    end

    # blocks
    for var k = blocks.ptr, k < blocks.limit, k += 1 do
        k.frame = 0
        if k.state == BLOCK_STATE_DYING then
            k.frame = 1 + k.tick / 2
            k.tick += 1
            if k.tick > 20 then
                k.state = BLOCK_STATE_DEAD
            end
        end
    end
end


func draw_stage()

    # border
    for var i = 0, i < 19, i += 1 do
        for var j = 0, j < 9, j += 1 do
            sprite(i * 16, BORDER + j * 16, 16, 16, 336, 32, 0)
        end
    end
    sprite(0, 0, SCREEN_W, SCREEN_H, 0, 32, 0)


    # pad
    sprite(PAD_X, pad.y / Q, PAD_W, pad.h - 8, 0, 224, 0)
    sprite(PAD_X, pad.y / Q + pad.h - 8, PAD_W, 8, 0, 224, 2)

    # blocks
    for var k = blocks.ptr, k < blocks.limit, k += 1 do
        if k.state == BLOCK_STATE_DEAD then continue end
        sprite(k.x, k.y, BLOCK_W, BLOCK_W, k.frame * 16, 336 + k.theme * 16, 0)
        if k.state == BLOCK_STATE_NORMAL then
            sprite(k.x, k.y, BLOCK_W, BLOCK_W, k.type * 16, 304, 0)
        end
    end

    # balls
    for var b = balls.ptr, b < balls.limit, b += 1 do
        if b.state == BALL_STATE_DEAD then continue end
        sprite(b.x / Q - 4, b.y / Q - 4, 16, 16, b.frame * 16, 320, 0)
    end


    print(5, 5, "LIVES")
    int_to_str(lives)
    print(5 + 8*6, 5, format_str.ptr)

    print(5, 180 - 18 + 5, "SCORE")
    var len = int_to_str(score)
    for i = 0, i < 4-len, i += 1 do
        putchar(5 + 8*6 + i * 8, 180 - 18 + 5, 48)
    end

    print(5 + 8*10 - len*8, 180 - 18 + 5, format_str.ptr)

    if game_state == GAME_STATE_CLEAR then
        print(116, 86, "STAGE CLEAR")
    elif game_state == GAME_STATE_DEAD then
        print(124, 86, "GAME OVER")
    end
end


func update()
    update_stage()
    draw_stage()
    prev_input = input

    update_sound()
end
