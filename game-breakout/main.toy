include "prelude.toy"
include "util.toy"

const Q = 256

const BORDER      = 18
const BALL_W      = 4
const BLOCK_W     = 16
const PAD_W       = 8
const PAD_X       = 38
const PAD_START_H = 40
const ACC         = 100


struct Ball
    alive
    x
    y
    vx
    vy
    spin
end

struct Block
    alive
    x
    y
    anim
end

struct Pad
    y
    h
    vy
end

var balls:  Ball[20]
var blocks: Block[117]
var pad:    Pad

var blocks_alive
var balls_alive

func add_ball(x, y): Ball*
    for var b = balls.ptr, b < balls.limit, b += 1 do
        if not b.alive then
            b.alive = 1
            b.x     = x
            b.y     = y
            b.vx    = 400 + rand(-100, 100)
            b.vy    = 300 + rand(-100, 100)
            if rand(0, 1) then
                b.vy *= -1
            end
            b.spin  = 0

            # # XXX
            # b.vy = 0
            # b.vx *= -1
            # b.x += 100 * Q

            return b
        end
    end
    return 0
end


func box_intersect(ax, ay, aw, ah, bx, by, bw, bh)
    return ax < bx + bw and ax + aw > bx and
           ay < by + bh and ay + ah > by
end
func box_overlap_x(ax, ay, aw, ah, bx, by, bw, bh)
    if not box_intersect(ax, ay, aw, ah, bx, by, bw, bh) then return 0 end
    var d1 = bx + bw - ax
    var d2 = bx - (ax + aw)
    if abs(d1) < abs(d2) then return d1 else return d2 end
end
func box_overlap_y(ax, ay, aw, ah, bx, by, bw, bh)
    if not box_intersect(ax, ay, aw, ah, bx, by, bw, bh) then return 0 end
    var d1 = by + bh - ay
    var d2 = by - (ay + ah)
    if abs(d1) < abs(d2) then return d1 else return d2 end
end


func init()
    pad.h = PAD_START_H
    pad.y = (SCREEN_H/2 - (pad.h / 2)) * Q

    add_ball((PAD_X + PAD_W) * Q, pad.y + (pad.h / 2 - BALL_W / 2) * Q)


    var k = blocks.ptr
    for var i = 4, i < 11, i += 1 do
        for var j = 0, j < 9, j += 1 do
            k.alive = 1
            k.x = 94 + i * BLOCK_W
            k.y = BORDER + j * BLOCK_W
            k += 1
            k.anim = 10
        end
    end

    while k < blocks.limit do
        k.alive = 0
        k += 1
    end

end


func update_ball(b: Ball*)
    if not b.alive then return end
    balls_alive += 1

    # spin
    b.spin = clamp(0, b.spin - 10, b.spin + 10)
    var s = clamp(b.spin, -50, 50)
    if s != 0 then
        var nx = b.vx
        var ny = b.vy
        b.vx += ny * s / 6000
        b.vy -= nx * s / 6000
    end

    # move x
    b.x += b.vx

    # pad collision
    var overlap = box_overlap_x(b.x / Q, b.y / Q, BALL_W, BALL_W, PAD_X, pad.y / Q, PAD_W, pad.h)
    if overlap then
        b.x = ((b.x / Q) + overlap) * Q
        b.spin = pad.vy

        var speed = sqrt(b.vx * b.vx + b.vy * b.vy)
        speed += 20 # inc speed
        b.vx = abs(b.vx)
        b.vy += pad.vy *2/3
        var speed2 = sqrt(b.vx * b.vx + b.vy * b.vy)
        b.vx = b.vx * speed / speed2
        b.vy = b.vy * speed / speed2
    end


    # block collision
    overlap = 0
    for var k = blocks.ptr, k < blocks.limit, k += 1 do
        if not k.alive then continue end
        var o = box_overlap_x(b.x / Q, b.y / Q, BALL_W, BALL_W, k.x, k.y, BLOCK_W, BLOCK_W)
        if o then
            k.alive = 0
            overlap = o
        end
    end
    if overlap then
        b.vx *= -1
        b.x = ((b.x / Q) + overlap) * Q
        b.vx += rand(-50, 50)
        b.vy += rand(-50, 50)
    end

    # wall collision
    if b.x > (SCREEN_W - BALL_W - BORDER) * Q then
        b.x = (SCREEN_W - BALL_W - BORDER) * Q
        b.vx = -abs(b.vx)
    end


    # move y
    b.y += b.vy

    # pad collision
    overlap = box_overlap_y(b.x / Q, b.y / Q, BALL_W, BALL_W, PAD_X, pad.y / Q, PAD_W, pad.h)
    if overlap then
        b.vy *= -1
        b.y = ((b.y / Q) + overlap) * Q
    end


    # block collision
    overlap = 0
    for k = blocks.ptr, k < blocks.limit, k += 1 do
        if not k.alive then continue end
        o = box_overlap_y(b.x / Q, b.y / Q, BALL_W, BALL_W, k.x, k.y, BLOCK_W, BLOCK_W)
        if o then
            k.alive = 0
            overlap = o
        end
    end
    if overlap then
        b.vy *= -1
        b.y = ((b.y / Q) + overlap) * Q
        b.vx += rand(-50, 50)
        b.vy += rand(-50, 50)
    end


    # wall collision
    if b.y < BORDER * Q then
        b.y = BORDER * Q
        b.vy = abs(b.vy)
    end
    if b.y > (SCREEN_H - BALL_W - BORDER) * Q then
        b.y = (SCREEN_H - BALL_W - BORDER) * Q
        b.vy = -abs(b.vy)
    end


    # die
    if b.x < -100 * Q then
        b.alive = 0
    end

    # draw
    sprite(b.x / Q, b.y / Q, BALL_W, BALL_W, 16, 224, 0)
end



func update()

    # draw stage
    sprite(0, 0, SCREEN_W, SCREEN_H, 0, 32, 0)


    # pad
    var dy = 0
    if btn & BTN_UP   then dy -= 1 end
    if btn & BTN_DOWN then dy += 1 end
    pad.vy = clamp(dy * (3 * Q), pad.vy - ACC, pad.vy + ACC)

    pad.y += pad.vy
    if pad.y < BORDER * Q then
        pad.y = BORDER * Q
        pad.vy = 0
    end
    if pad.y > (SCREEN_H - BORDER - pad.h) * Q then
        pad.y = (SCREEN_H - BORDER - pad.h) * Q
        pad.vy = 0
    end

    sprite(PAD_X, pad.y / Q, PAD_W, pad.h - 8, 0, 224, 0)
    sprite(PAD_X, pad.y / Q + pad.h - 8, PAD_W, 8, 0, 224, 2)


    # update balls
    balls_alive = 0
    for var b = balls.ptr, b < balls.limit, b += 1 do
        if not b.alive then continue end

        # pad collision
        var overlap = box_overlap_y(b.x / Q, b.y / Q, BALL_W, BALL_W, PAD_X, pad.y / Q, PAD_W, pad.h)
        if overlap then
            if pad.vy > 0 then
                b.vy = abs(pad.vy)
            elif pad.vy < 0 then
                b.vy = -abs(pad.vy)
            else
                b.vy *= -1
            end
            b.y = ((b.y / Q) + overlap) * Q
        end

        update_ball(b)
    end

    # spawn new ball
    if balls_alive == 0 then
        add_ball((PAD_X + PAD_W) * Q, pad.y + (pad.h / 2 - BALL_W / 2) * Q)
    end


    # draw blocks
    blocks_alive = 0
    for var k = blocks.ptr, k < blocks.limit, k += 1 do
        if k.alive then
            blocks_alive += 1
            sprite(k.x, k.y, BLOCK_W, BLOCK_W, 32, 224, 0)
        elif k.anim > 0 then
            var frame = 10 - k.anim
            sprite(k.x, k.y, BLOCK_W, BLOCK_W, 48 + frame * 16, 224, 0)
            k.anim -= 1
        end
    end


    print(5, 5, "BLOCKS LEFT:")
    print(5 + 8*13, 5, int_to_str(blocks_alive))
end
