include "prelude.toy"
include "util.toy"
include "sound.toy"

const Q = 256

const BALL_STATE_DEAD     = 0
const BALL_STATE_FLYING   = 1
const BALL_STATE_STICKING = 2

const BLOCK_STATE_DEAD   = 0
const BLOCK_STATE_NORMAL = 1
const BLOCK_STATE_DYING  = 2
const BLOCK_THEMES = 4
const BLOCK_TYPE_NORMAL    = 0
const BLOCK_TYPE_EXTRABALL = 1

const GAME_STATE_PLAYING = 0
const GAME_STATE_CLEAR   = 1
const GAME_STATE_DEAD    = 2

const BORDER       = 18
const BALL_W       = 8
const BLOCK_W      = 16
const PAD_W        = 8
const PAD_X        = 38
const PAD_START_H  = 40
const ACC          = 100


struct Ball:
    state
    tick
    frame
    spin
    x
    y
    vx
    vy


struct Block:
    state
    tick
    frame
    theme
    type
    x
    y

struct Pad:
    is_sticky
    y
    h
    vy

var game_state
var blocks_alive
var balls_alive
var balls_spinning
var lives
var score

var balls:  Ball[20]
var blocks: Block[117]
var pad:    Pad

var prev_input

func is_just_pressed(button): return input & button & (-1-prev_input)

func new_ball() -> Ball*:
    for b in balls:
        if b.state != BALL_STATE_DEAD: continue
        b.state = BALL_STATE_STICKING
        b.tick  = 0
        b.frame = 0
        b.spin  = 0
        b.x     = (PAD_X + PAD_W) * Q
        b.y     = pad.y + pad.h * (Q / 2) - BALL_W * Q / 2
        b.vx    = 500
        b.vy    = 400
        if rand(0, 1): b.vy *= -1
        return b

func unstick_balls():
    for b in balls:
        if b.state != BALL_STATE_STICKING: continue
        b.state = BALL_STATE_FLYING
        sound(SOUND_UNSTICK)


func init_stage():
    game_state = GAME_STATE_PLAYING

    # pad
    pad.is_sticky = 0
    pad.h         = PAD_START_H
    pad.y         = (SCREEN_H/2 - (pad.h / 2)) * Q
    pad.vy        = 0

    # balls
    for b in balls: b.state = BALL_STATE_DEAD
    new_ball()

    # blocks
    blocks_alive = 0
    var k = blocks.ptr
    for i = 4, 11:
        for j = 0, 9:
            blocks_alive += 1
            k.state = BLOCK_STATE_NORMAL
            k.tick  = 0
            k.frame = 0
            k.theme = rand(0, BLOCK_THEMES - 1)
            k.type  = BLOCK_TYPE_NORMAL
            k.x     = 94 + i * BLOCK_W
            k.y     = BORDER + j * BLOCK_W
            k += 1

    while k < blocks.limit:
        k.state = BLOCK_STATE_DEAD
        k += 1

    i = 5
    while i:
        k = &blocks[rand(0, blocks_alive - 1)]
        if k.type == BLOCK_TYPE_NORMAL:
            k.type = BLOCK_TYPE_EXTRABALL
            i -= 1

func init():
    lives = 3
    score = 0
    init_stage()


const AXIS_X = 0
const AXIS_Y = 1

func block_collision(b: Ball*, axis):
    var overlap = 0
    for k in blocks:
        if k.state != BLOCK_STATE_NORMAL: continue
        var o
        if axis == AXIS_X: o = box_overlap_x(b.x / Q, b.y / Q, BALL_W, BALL_W, k.x, k.y, BLOCK_W, BLOCK_W)
        else:              o = box_overlap_y(b.x / Q, b.y / Q, BALL_W, BALL_W, k.x, k.y, BLOCK_W, BLOCK_W)
        if o != 0:
            overlap = o
            score        += 1
            blocks_alive -= 1
            k.state = BLOCK_STATE_DYING
            # extra ball!
            if k.type == BLOCK_TYPE_EXTRABALL:
                var n = new_ball()
                if n:
                    n.state = BALL_STATE_FLYING
                    n.x = b.x
                    n.y = b.y
                    if rand(0, 1) == 0: b.vx *= -1
    if overlap:
        sound(SOUND_BLOCK)
        if axis == AXIS_X:
            b.vx *= -1
            b.x = ((b.x / Q) + overlap) * Q
        else:
            b.vy *= -1
            b.y = ((b.y / Q) + overlap) * Q
        b.vx += rand(-20, 20)
        b.vy += rand(-20, 20)


func update_ball(b: Ball*):
    if b.state == BALL_STATE_DEAD: return

    # pad y collision
    var overlap = box_overlap_y(b.x / Q, b.y / Q, BALL_W, BALL_W, PAD_X, pad.y / Q, PAD_W, pad.h)
    if overlap:
        sound(SOUND_BING)

        b.y = ((b.y / Q) + overlap) * Q
        if   pad.vy > 0: b.vy = abs(pad.vy)
        elif pad.vy < 0: b.vy = -abs(pad.vy)
        else:            b.vy *= -1

    # spin
    b.spin = clamp(0, b.spin - 20, b.spin + 20)
    var s = clamp(b.spin, -100, 100)
    if s != 0:
        var nx = b.vx
        var ny = b.vy
        b.vx += ny * s / 6000
        b.vy -= nx * s / 6000

    # move x
    if b.state != BALL_STATE_STICKING: b.x += b.vx

    # pad collision
    overlap = box_overlap_x(b.x / Q, b.y / Q, BALL_W, BALL_W, PAD_X, pad.y / Q, PAD_W, pad.h)
    if overlap:
        sound(SOUND_BING)

        b.x    = ((b.x / Q) + overlap) * Q
        b.spin = pad.vy
        var speed = sqrt(b.vx * b.vx + b.vy * b.vy)
        speed += 5 # increase speed
        b.vx = abs(b.vx)
        b.vy += pad.vy / 4
        var speed2 = sqrt(b.vx * b.vx + b.vy * b.vy)
        b.vx   = b.vx * speed / speed2
        b.vy   = b.vy * speed / speed2
        b.tick = 0
        if pad.is_sticky: b.state = BALL_STATE_STICKING


    # block collision
    block_collision(b, AXIS_X)

    # wall collision
    if b.x > (SCREEN_W - BALL_W - BORDER) * Q:
        b.x = (SCREEN_W - BALL_W - BORDER) * Q
        b.vx = -abs(b.vx)
        sound(SOUND_BING)

    # move y
    if b.state != BALL_STATE_STICKING: b.y += b.vy
    else:                              b.y += pad.vy

    # block collision
    block_collision(b, AXIS_Y)

    # wall collision
    if b.y < BORDER * Q:
        b.y = BORDER * Q
        b.vy = abs(b.vy)
        if abs(b.vx) < 100:
            if b.vx > 0: b.vx += 10
            if b.vx < 0: b.vx -= 10
        sound(SOUND_BING)
    if b.y > (SCREEN_H - BALL_W - BORDER) * Q:
        b.y = (SCREEN_H - BALL_W - BORDER) * Q
        b.vy = -abs(b.vy)
        sound(SOUND_BING)

    # die
    if b.x < -BALL_W * Q: b.state = BALL_STATE_DEAD

    # set frame
    b.frame = 0
    if b.spin != 0:
        b.frame = 1 + b.tick % 8
        if b.spin > 0: b.frame = 9 - b.frame

    balls_alive += 1
    if b.spin != 0: balls_spinning += 1

    b.tick += 1



func update_stage():
    if game_state == GAME_STATE_PLAYING:

        # pad
        var dy = 0
        if input & INPUT_UP:   dy -= 1
        if input & INPUT_DOWN: dy += 1
        pad.vy = clamp(dy * (4 * Q), pad.vy - ACC, pad.vy + ACC)

        pad.y += pad.vy
        if pad.y < BORDER * Q:
            pad.y = BORDER * Q
            pad.vy = 0
        if pad.y > (SCREEN_H - BORDER - pad.h) * Q:
            pad.y = (SCREEN_H - BORDER - pad.h) * Q
            pad.vy = 0

        if is_just_pressed(INPUT_A): unstick_balls()

        # balls
        balls_alive = 0
        var prev_spinning = balls_spinning
        balls_spinning = 0
        for b in balls: update_ball(b)
        if balls_alive == 0:
            sound(SOUND_DIE)
            if lives > 0:
                lives -= 1
                new_ball()
            else:
                game_state = GAME_STATE_DEAD
        if prev_spinning != balls_spinning:
            if prev_spinning == 0: sound(SOUND_SPIN)
            if balls_spinning == 0: sound(SOUND_NOSPIN)

        # stage clear
        if blocks_alive <= 0:
            for b in balls:
                b.vx = 0
                b.vy = 0
            game_state = GAME_STATE_CLEAR

    elif game_state == GAME_STATE_CLEAR:
        if is_just_pressed(INPUT_A): init_stage()
    elif game_state == GAME_STATE_DEAD:
        if is_just_pressed(INPUT_A): init()

    # blocks
    for k in blocks:
        k.frame = 0
        if k.state == BLOCK_STATE_DYING:
            k.frame = 1 + k.tick / 2
            k.tick += 1
            if k.tick > 20: k.state = BLOCK_STATE_DEAD


func draw_stage():

    # border
    for i = 0, 19: for j = 0, 9: sprite(i * 16, BORDER + j * 16, 16, 16, 336, 32, 0)
    sprite(0, 0, SCREEN_W, SCREEN_H, 0, 32, 0)

    # pad
    sprite(PAD_X, pad.y / Q, PAD_W, pad.h - 8, 0, 224, 0)
    sprite(PAD_X, pad.y / Q + pad.h - 8, PAD_W, 8, 0, 224, 2)

    # blocks
    for k in blocks:
        if k.state == BLOCK_STATE_DEAD: continue
        sprite(k.x, k.y, BLOCK_W, BLOCK_W, k.frame * 16, 336 + k.theme * 16, 0)
        if k.state == BLOCK_STATE_NORMAL:
            sprite(k.x, k.y, BLOCK_W, BLOCK_W, k.type * 16, 304, 0)

    # balls
    for b in balls:
        if b.state == BALL_STATE_DEAD: continue
        sprite(b.x / Q - 4, b.y / Q - 4, 16, 16, b.frame * 16, 320, 0)

    print(5, 5, "LIVES")
    int_to_str(lives)
    print(5 + 8*6, 5, format_str.ptr)

    print(5, 180 - 18 + 5, "SCORE")
    var len = int_to_str(score)
    for i = 0, 4 - len:
        putchar(5 + 8*6 + i * 8, 180 - 18 + 5, 48)

    print(5 + 8*10 - len * 8, 180 - 18 + 5, format_str.ptr)

    if game_state == GAME_STATE_CLEAR:  print(116, 86, "STAGE CLEAR")
    elif game_state == GAME_STATE_DEAD: print(124, 86, "GAME OVER")


func update():
    update_stage()
    update_sound()
    prev_input = input
    draw_stage()

